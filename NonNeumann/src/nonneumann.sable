Package nonneumann;

Helpers
 tudo = [0..0xffff];
 digito = ['0'..'9'];
 espaco = ' ';
 rc = 13;
 nl = 10;
 tab = 9;
 pt_virg = 59;
 letra = [['a'..'z'] + ['A'..'Z']];
 hexad = ['0'..'9'] | ['A'..'F'] | ['a'..'f'];
 tudo_semnl = [tudo - [nl + rc]];
 nova_linha = [nl + rc];
 tudo_notraco = [tudo - '-'];
 sem_traco_fecha = [tudo -['-' + '}']];
 esq_boxcoment = '{-';
 dir_boxcoment = '-}';  
 
 Tokens
 coment_linha = pt_virg (tudo_semnl)* nova_linha+; 
 coment_box =  esq_boxcoment tudo_notraco* '-' (sem_traco_fecha tudo_notraco* '-'+)* '}';
 entrar = 'entry';
 par_esq = '(';
 par_dir = ')';
 
 /* ALTERAÇÃO! Bem no início do projeto, eu achei que as chaves seriam tokens, mas percebi que
               elas apenas indicavam o fecho. Então alterei as chaves pelos colchetes,
               mas acabei trocando os nomes e mantendo sem perceber os símbolos de chaves que
               estavam entre aspas simples. O que me fez confundir e criar depois outros tokens
               para colchetes, sendo que estes já deveriam ter virados tokens para colchetes.
 colch_e = '{';
 colch_d = '}';
 */
 
 colch_e = '[';
 colch_d = ']';
 funcao = 'function';
 constante = 'const';
 funcao_unica = 'lambda';
 
 /* ALTERAÇÃO! Como eu não alterei os símbolos de chaves pelos símbolos de colchetes anteriormente,
               então acabei criando novos tokens para os colchetes. Sendo que já eram pra existir,
               ao ter feito a subtituição no lugar das chaves. Então, esses novos tokens eu deletei
               e mantive apenas os tokens de colchetes anteriores, e com os símbolos entres aspas simples
               corrigidos para colchetes ao invés de chaves.
 col_esq = '[';
 col_dir = ']';
 */
 
 tipo_int = 'int';
 tipo_real = 'real';
 tipo_bool = 'bool';
 virgula = ',';
 dois_pontos = ':';
 negacao_booleana = '!';
 e = 'and';
 ou = 'or';
 verdade = 'true';
 falso = 'false';
 igual = '=';
 menor_que = '<';
 maior_que = '>';
 soma = '+';
 subt = '-';
 mult = '*';
 div = '/';
 mod = '%';
 se = 'if';
 entao = 'then';
 senao = 'else';
 
 /* ALTERAÇÃO! Durante a primeira etapa encontrei um problema que era: -2 não era identificado como um
               número inteiro, e -3.14 não era identificado como um número real.
               Então para consertar isso, coloquei o símbolo '-' como opcional antes da digitação do
               valor. Mas ao desenvolver o sintático, existiu um conflito entre o token subt na produção
               de subtração, e o '-' opcional que estava na expressão regular dos números.
               Então, tive que remover esse '-' da expressão regular, deixando para o sintático e
               posteriormente o semântico cuidar disto.
 numero_real = '-'? (digito)+ '.' (digito)+ | '-'? (digito)+ 'E' '-'? (digito)+; 
 numero_inteiro = '-'? (digito)+ | '0x' (hexad)+;
 */
 
 numero_real = (digito)+ '.' (digito)+ | (digito)+ 'E' '-'? (digito)+; 
 numero_inteiro = (digito)+ | '0x' (hexad)+;
 identificador = (letra | '_')+ ;
 vazio = (espaco | rc | nl | tab)+;
 
Ignored Tokens
 vazio, coment_linha, coment_box;
 
Productions
 programa =
   {declaracao_de_funcao} dec_estrutura_funcao*;

 dec_estrutura_funcao =
   {declara_estrutura_funcao} entrar? par_esq dec_funcao_esq par_dir;

 dec_funcao_esq =
   {declara_funcao_lado_esq} funcao tipo identificador par_esq parametros par_dir dec_funcao_dir;
   
 dec_funcao_dir =
   {declara_funcao_lado_dir} dois_pontos par_esq exp par_dir;

 tipo =
   {inteiro} tipo_int 
  |{real} tipo_real
  |{boolean} tipo_bool;

 parametros =
   {declarando_parametros} parametro cont_parametros;

 cont_parametros =
   {declarando_mais_parametros} virgula parametros
  | ;

 parametro =
   {parametro_simples} tipo identificador
  |{parametro_assinatura} assinatura
  | ;

 assinatura =
   {assina} tipo identificador par_esq parametros_assinatura par_dir;

 parametros_assinatura =
   {param_assinatura} parametro_assinatura cont_parametros_assinatura
  | ;
  
 cont_parametros_assinatura =
   {declarando_mais_param_assinatura} virgula parametros_assinatura
  | ;

 parametro_assinatura =
   {forma_tipo_assinatura} tipo
  |{nova_assinatura} assinatura;
 
 exp =
   {comeco} estru_cond;

 estru_cond =
   {ir_logico_ou} logico_ou
  |{estru_se_senao} se bloco_exp estru_cond_entao senao exp;

 estru_cond_entao =
   {estru_entao} entao exp;

 logico_ou =
   {ir_logico_e} logico_e
  |{op_ou} logico_ou ou logico_e;

 logico_e =
   {ir_logico_negacao} logico_negacao
  |{op_e} logico_e e logico_negacao;
  
 logico_negacao =
   {ir_relacionais} relacionais
  |{op_neg} negacao_booleana relacionais;

 relacionais =
   {ir_aritmeticos} aritmeticos
  |{op_menor_que} relacionais menor_que aritmeticos
  |{op_maior_que} relacionais maior_que aritmeticos
  |{op_iguais} relacionais igual aritmeticos;
 
 aritmeticos =
   {prox_aritmeticos} cont_aritmeticos
  |{soma} aritmeticos soma cont_aritmeticos
  |{subtracao} aritmeticos? subt cont_aritmeticos;
  
 cont_aritmeticos =
   {ir_termos} termos
  |{multiplicacao} cont_aritmeticos mult termos
  |{divisao} cont_aritmeticos div termos
  |{modulo} cont_aritmeticos mod termos;
  
 termos =
   {num_inteiros} numero_inteiro
  |{num_reais} numero_real
  |{identificador_param} identificador
  |{bool_verdade} verdade
  |{bool_falso} falso
  |{bloco_expressao} bloco_exp
  |{chamada_func} chamada
  |{func_unica_lambda} lambda;

 lambda =
   {lado_esq_func} funcao_unica par_esq lista_ids par_dir lambda_dir;
   
 lambda_dir =
   {lado_dir_func} dois_pontos par_esq exp par_dir colch_e lista_exp colch_d;
  
 chamada =
   {estrut_chamada} identificador par_esq lista_exp par_dir;
   
 lista_exp =
   {novo_exp} exp cont_exp;
 
 cont_exp =
   {mais_exp} virgula lista_exp
  | ;

 lista_ids =
   {novo_id} identificador cont_ids;
 
 cont_ids =
   {mais_ids} virgula lista_ids
  | ;
  
 bloco_exp =
   {estrutura} par_esq dec_cons* exp par_dir;

 dec_cons =
   {estrutura_constante} par_esq conteudo_cons par_dir;
   
 conteudo_cons =
   {conteudo_declaracao_cons} constante tipo identificador par_esq exp par_dir;
